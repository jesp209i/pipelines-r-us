name: pipeline

on:
  push:
    branches:
     - main
     - using_project-id
     - powershell
     - pwsh-get-changes

env:
  projectId: ${{ vars.PROJECT_ID }}
  umbracoCloudApiKey: ${{ secrets.UMBRACO_CLOUD_API_KEY }}

jobs:
  preflight:
    name: Preflight checks
    runs-on: ubuntu-latest
    steps:
      # Gets the latest CICD Flow deployment if there is any
      # Will write "latestDeploymentId" to pipeline variables, value can be an uuid or empty string 
      - uses: actions/checkout@v3
      - name: Get Latest Deployment
        id: latest-deployment
        shell: pwsh
        run: >
          ${{GITHUB.WORKSPACE}}/.github/powershell/get-latest-deployment.ps1 
          -ProjectId ${{ env.projectId }} 
          -ApiKey ${{ env.umbracoCloudApiKey }} 
          -PipelineVendor GITHUB
    outputs: 
      latestDeployemntId: steps.latest-deployment.outputs.latestDeploymentId

  checkForChanges:
    name: Check if there are changes since latest deployment
    needs: preflight
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      # Download git-patch file based on latest deployment
      # Will write "remoteChanges" to pipeline variables, value can be "yes" or "no"
      # When "remoteChanges" is yes, there will also be downloaded a patch-file to the path you specified in -DownloadFolder parameter
      - name: Fetch Changes From Cloud
        if: ${{ needs.preflight.outputs.latestDeploymentId != '' }}
        id: latest-changes
        shell: pwsh
        run: >
          ${{GITHUB.WORKSPACE}}/.github/powershell/get-changes-by-id.ps1 
          -ProjectId ${{ env.projectId }} 
          -ApiKey ${{ env.umbracoCloudApiKey }} 
          -DeploymentId ${{ needs.preflight.outputs.latestDeploymentId }}
          -DownloadFolder ${{GITHUB.WORKSPACE}}/patch
          -PipelineVendor GITHUB

      - name: See diff content if any
        if: ${{ steps.latest-changes.outputs.remoteChanges == 'yes' }}
        shell: pwsh
        run: get-content ${{GITHUB.WORKSPACE}}/patch/git-patch.diff

      - name: Store diff before applying
        if: ${{ steps.latest-changes.outputs.remoteChanges == 'yes' }}
        uses: actions/upload-artifact@v3
        with:
          name: git-patch
          path: ${{GITHUB.WORKSPACE}}/patch/git-patch.diff
          retention-days: 1
    outputs:
      remoteChanges: steps.latest-changes.outputs.remoteChanges

  applyRemoteChanges:
    name: Apply remote changes
    needs: checkForChanges
    runs-on: ubuntu-latest
    steps:
      - name: hello
        if: ${{ needs.checkForChanges.outputs.remoteChanges == 'yes' }}
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get stored diff
        if: ${{ needs.checkForChanges.outputs.remoteChanges == 'yes' }}
        uses: actions/download-artifact@v3
        with:
          name: git-patch
          path: ${{GITHUB.WORKSPACE}}/patch/git-patch.diff
      
      - name: Apply Change
        if: ${{ needs.checkForChanges.outputs.remoteChanges == 'yes' }}
        run: |
          git config user.name github-actions
          git config user.email github-actions@github.com
          git apply ${{GITHUB.WORKSPACE}}/patch/git-patch.diff
          git add *
          git commit -m "Adding changes in pipeline [skip ci]"
          git push

  ## From Azure Devops

  #     - job: ApplyChanges
  #       displayName: Apply remote change
  #       dependsOn: CheckRemoteChanges
  #       condition: eq(dependencies.CheckRemoteChanges.outputs['get_remote_changes.remoteChanges'], 'yes')
  #       variables:
  #         gitPatchFile: $[ dependencies.CheckRemoteChanges.outputs['get_remote_changes.remoteChangeFile'] ]
  #       steps:
  #         - download: current
  #           displayName: Get patch file to apply
  #           artifact: PatchFile
  #         - bash: |
  #             git config user.name "Build pipeline"
  #             git config user.email email@email.com
  #             git switch -c auto/merge_remote_changes_for_$(Build.BuildNumber)
  #             git apply -v $(Pipeline.Workspace)/PatchFile/$(gitPatchFile)
  #             git commit -m "Auto updated changes from remote for build $(Build.BuildNumber)" .
  #             git remote add tmp-pusher https://company-repository-name@dev.azure.com/company-repository-name/azuredevops-project-name/_git/azuredevops-project-name
  #             git push --set-upstream tmp-pusher auto/merge_remote_changes_for_$(Build.BuildNumber)
  #           displayName: Applying git patch to new branch
  #     - job: ManualApproval
  #       displayName: Possible Manual Approval gate
  #       dependsOn: [CheckRemoteChanges,ApplyChanges]
  #       condition: and(succeeded(), eq(dependencies.CheckRemoteChanges.outputs['get_remote_changes.remoteChanges'], 'yes'))
  #       pool: server
  #       steps:
  #         - task: ManualValidation@0
  #           displayName: Merge remote changes manually
  #           timeoutInMinutes: 30
  #           inputs:
  #             notifyUsers: |
  #               username
  #             instructions: 'Please merge auto/merge_remote_changes_for_$(Build.BuildNumber) and restart build. If this was already done, please just let this step continue.'
  #             onTimeout: 'reject'

  publish:
    name: Zip and Publish to Cloud
    runs-on: ubuntu-latest
    needs: [applyRemoteChanges]
    steps:
      - name: fail # fail fast before sending to cloud
        run: exit 1;

      - uses: actions/checkout@v3

      # switch the gitignore files so cloud does not ignore the build frontend assets
      - name: Prepare Cloud Git Ignore
        run: cp cloud.gitignore .gitignore
        shell: bash

      # zip everything, except what is defined in the '.zipignore'
      - name: Zip Source Code
        run: zip -r sources.zip . -x@cloud.zipignore
        shell: bash

      # Request to prepare a deployment
      # - sets the commit message to be used in cloud 
      # - supplies you with a deploymentId to be used in the rest of the process
      - name: Create Deployment Meta
        id: deployment-meta
        shell: pwsh
        run: >
          ${{GITHUB.WORKSPACE}}/.github/powershell/new-deployment.ps1 
          -ProjectId ${{ env.projectId }} 
          -ApiKey ${{ env.umbracoCloudApiKey }} 
          -CommitMessage "Run number ${{github.run_number}}" 
          -PipelineVendor GITHUB

      # Upload your zipped artifact
      - name: Post Zipped Artifact
        shell: pwsh
        run: >
          ${{GITHUB.WORKSPACE}}/.github/powershell/add-deployment-package.ps1 
          -ProjectId ${{ env.projectId }} 
          -DeploymentId ${{ steps.deployment-meta.outputs.deploymentId }} 
          -ApiKey ${{ env.umbracoCloudApiKey }} 
          -FilePath ${{ GITHUB.WORKSPACE }}/sources.zip

      # Actually request to start the deployment process in cloud
      - name: Request Start Deployment
        shell: pwsh
        run: >
          ${{GITHUB.WORKSPACE}}/.github/powershell/start-deployment.ps1 
          -ProjectId ${{ env.projectId }} 
          -DeploymentId ${{ steps.deployment-meta.outputs.deploymentId }} 
          -ApiKey ${{ env.umbracoCloudApiKey }}

      # Poll until deployment finishes 
      - name: Wait for deployment completed 
        shell: pwsh
        run: >
          ${{GITHUB.WORKSPACE}}/.github/powershell/test-deployment-status.ps1 
          -ProjectId ${{ env.projectId }} 
          -DeploymentId ${{ steps.deployment-meta.outputs.deploymentId }} 
          -ApiKey ${{ env.umbracoCloudApiKey }}
